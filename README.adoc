= Introduction to the Project Riff Funcctions-as-a-Service Platform

Mario Gray <mgray@pivotal.io>
:Author Initials: MVG
:toc:
:icons:
:numbered:
:website: https://github.com/projectRiff/Riff=


=== Motivation
Functions as a Service are a new paradigm for application composition and deployment.
Functions are a smaller deployable unit than microservices or traditional monoliths.

https://projectRiff.io/[Project Riff] is a new Pivotal project that runs functions in a 
cloud environment like Pivotal Container Services (Kubernetes).

Lets get started by setting up a new Riff environment and then creating some functions.

.Navigating uncharted waters with Helm
**********************************************************************

All of the steps to manually prepare the environment locally are
outlined in the https://github.com/projectRiff/Riff[Riff Github Repo].

Helm is a package manager for Kubernetes. Riff provides helm packages
- Helm "charts" - to ease installation and migration.

For further information on installing Helm, refer to the project's 
https://docs.helm.sh/using_helm/#from-script[Installation guide].

**********************************************************************

[[X7]]
== Preparing the environment
Either use an existing Kubernetes environement, or check out these 
tools that provide a useful (but not complete!) alternative to
installing Kubernetes locally:

* https://www.katacoda.com/courses/Kubernetes/playground[katacode]
* https://labs.play-with-k8s.com/[play-with-k8s]

In this demo, we assume Minikube `0.25` with Helm `2.7.2`.
Make sure to start Minikube (`minikube start --memory=4096`).


[[X8]]
=== Installing the Riff Environment with Helm

If you are on OSX, install Helm with Homebrew:

[source,script,indent=0]
----
brew install kubernetes-helm
----

If you are on a Linux distribution, or simply want to install things manually on OSX or Windows,
follow https://github.com/Kubernetes/helm[the instructions for Helm].

Then, add the Helm chart for Riff:

[source,script,indent=0]
----
helm repo add riffrepo https://riff-charts.storage.googleapis.com
helm repo update
----

Install Riff with the release name `demo`:

[source,script,indent=0]
----
helm install riffrepo/riff --name demo
----

Once this command is complete, you will have a functioning Riff
environment. You can enumerate the Riff componenets using this command:

[source,script,indent=0]
----
kubectl get pods --show-labels -l app=riff
----

You'll notice several pods in service. The entry point to your functions
is `demo-riff-http-gateway`. Enter the following command to enumerate
Kubernetes services and ensure it is accepting connections from  `localhost`;

[source,script,indent=0]
----
kubectl get svc -l app=riff
----

Check that `demo-riff-http-gateway` has a `TYPE` of `NodePort`.

**********************************************************************
If your Riff-http-gateway says that EXTERNAL-IP is Pending and fails
to resolve after several minutes, then you may need to change the 
service type.

[source,script,indent=0]
----
kubectl edit service demo-riff-http-gateway
----
Update the `type` field from `LoadBalancer` to `NodePort`, and save.
This will expose your riff-http-gateway to the local network.

Additional networking configuration may be necessary as you might 
have subnetting/firewalls in place, especailly in a controlled 
environtment.
**********************************************************************

=== Installing the Riff Client

In order to use Riff, you'll need the `riff` command line client interface (CLI).
Clone https://github.com/projectRiff/Riff[the `git` repository] and add it to your `PATH`.
Now you can use `riff` in the shell.

=== Writing the Function.

Riff maintains a registry of functions. These functions can optionally accept payloads as requests
and optionally produce replies. Riff will forward requests to your functions and deliver replies
from your functions over message channels. Messages originate from a number of different sources:
HTTP, Kafka, RabbitMQ, etc. As of this writing, only HTTP is supported.

At the moment, Riff supports the following languages and runtimes: Python, Node.js, `/bin/bash`, and Java.
We will focus on Java in this example. Riff supports three standard Java 8 functional interfaces:

* `java.util.function.Supplier`: returns a value but does not take an argument
* `java.util.function.Function`: returns a value and accepts an argument
* `java.util.function.Consumer`: does not return a value but does accept an argument.

Let's look at a simple `Function<String,String>`, which both accepts an input argument and produces a reply.

.`DemoFunction.java`
[source,java,indent=0]
----
package mcp;

import java.util.function.Function;

public class DemoFunction implements Function<String, String> {

    public String apply(String s) {
        return new StringBuilder(s).reverse().toString();
    }
}
----

A `Supplier`  does not take an argument but does produce a reply.

.`DemoSupplier.java`
[source,java]
----
package mcp;

import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.function.Supplier;

public class DemoSupplier implements Supplier<String> {

	private List<String> kingsBook = Arrays.asList(
            "YKCOWREBBAJ",
            "sevot yhtils eht dna,gillirb sawTâ€™",
            "ebaw eht ni elbmig dna eryg diD",
            ",sevogorob eht erew ysmim llA",
            ".ebargtuo shtar emom eht dnA");

	private final Random random = new Random();

	public String get() {
		int r = random.nextInt() * kingsBook.size();
		return kingsBook.get(r);
	}
}
----

A `Consumer` does not accept an input argument, but does produce a reply.

.`DemoConsumer.java`
[source,java]
----
package mcp;

import lombok.extern.java.Log;

import java.util.function.Consumer;

@Log
public class DemoConsumer implements Consumer<String> {

    public void accept(String s) {
        log.info(s);
    }
}
----

=== Executing the function

We will need to create and deploy our function in a container. We can create our own `Dockerfile`,
service description (`.yaml`) configuration, and container images manually if we wanted to.
There is no need to, though, as Riff 0.0.3 will do all this for us!

.Deploy the `Function<String,String>`
[source,script]
----
riff create --name demofn --input reverse-in \
    --protocol pipes --artifact target/demofn-0.0.1.jar \
    --handler mcp.DemoFunction
----

This command creates a function. You specify the input and output topics, a fully
qualified classname and method, and the artifact (.jar) that contains the class.
Your topics are logical names for pipes that conduct requests and replies between
functions.

The following command will locate your `riff-http-gateway`'s IP and port,
then create an HTTP request that will be sent to the `reverse-in` topic.
We tell Riff to wait for a response payload from the input topic with
the `--reply` parameter.

.`riff-publish.sh`
[source,script]
----
riff publish --input reverse-in --data OIRAM --reply
----

Ultimately, the `Riff publish` comand issues an HTTP request to a REST API.
You can do the same thing with any standard HTTP client such as `curl`.

.`riff-curl.sh`
[source,script]
----
curl -H Content-Type: text/plain http://192.168.99.100:30101/messages/demoinput -d OIRAM
----