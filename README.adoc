= Introduction to the Project Riff Funcctions-as-a-Service Platform

Mario Gray <mgray@pivotal.io>
:Author Initials: MVG
:toc:
:icons:
:numbered:
:website: https://github.com/projectRiff/Riff=


=== Motivation
Functions as a Service are a new paradigm for application composition and deployment.
Functions are a smaller deployable unit than microservices or traditional monoliths.

https://projectRiff.io/[Project Riff] is a new Pivotal project that runs functions in a 
cloud environment like Pivotal Container Services (Kubernetes).

Lets get started by setting up a new Riff environment and then creating some functions.

.Navigating uncharted waters with Helm
**********************************************************************

All of the steps to manually prepare the environment locally are
outlined in the https://github.com/projectRiff/Riff[Riff Github Repo].

Helm is a package manager for Kubernetes. Riff provides helm packages
- Helm "charts" - to ease installation and migration.

For further information on installing Helm, refer to the project's 
https://docs.helm.sh/using_helm/#from-script[Installation guide].

**********************************************************************

[[X7]]
== Preparing the environment
Either use an existing Kubernetes environement, or check out these 
tools that provide a useful (but not complete!) alternative to
installing Kubernetes locally:

* https://www.katacoda.com/courses/Kubernetes/playground[katacode]
* https://labs.play-with-k8s.com/[play-with-k8s]

In this demo, we assume Minikube `0.25` with Helm `2.7.2`.

[[X8]]
=== Installing Riff with Helm 

If you are on OSX, install Helm with Homebrew:

[source,script,indent=0]
----
brew install Kubernetes-helm
----

If you are on a Linux distribution, or simply want to install things manually on OSX or Windows,
follow https://github.com/Kubernetes/helm[the instructions for Helm].

Then, add the Helm chart for Riff:

[source,script,indent=0]
----
helm repo add riffrepo https://Riff-charts.storage.googleapis.com
helm repo update
----

Install Riff with the release name `demo`:

[source,script,indent=0]
----
helm install riffrepo/riff --name demo
----

Once this command is complete, you will have a functioning Riff
environment.  You can enumerate the Riff componenets using this command:

[source,script,indent=0]
----
kubectl get pods --show-labels -l app=Riff
----

You'll notice serval pods in service.  The entry point to your functions
lies at `demo-Riff-http-gateway`.  To ensure it is accepting connections
from your localhost, enter the following command to enumerate Kubernetes 
services.

[source,scdript,indent=0]
----
kubectl get svc -l app=Riff
----

Check that `demo-Riff-http-gateway` has a `TYPE` of `NodePort`.

**********************************************************************
If your Riff-http-gateway says that EXTERNAL-IP is Pending and fails
to resolve after several minutes, then you may need to change the 
service type.

[source,script,indent=0]
----
kubectl edit service demo-Riff-http-gateway
----
Update the `type` field from `LoadBalancer` to `NodePort`, and save.
This will expose your Riff-http-gateway to the local network.

Additional networking configuration may be necessary as you might 
have subnetting/firewalls in place, especailly in a controlled 
environtment.
**********************************************************************

[[X9]]
=== Writing the Function.


Riff maintains a registry of functions. These functions expect payloads.
Riff will forward requests to your functions and deliver replies 
from your functions over message channels. You can originate messages
into your channels from a number of different sources: HTTP, Kafka, RabbitMQ,
etc. As of this writing, only HTTP is supported.

At the moment, Riff supports the following languages and runtimes:
Python, Node.js, `/bin/bash`, and Java. We will focus on Java in this
example.

Riff supports three standard Java 8 functional interfaces:

* `java.util.function.Supplier`: returns a value but does not take an argument
* `java.util.function.Function`: returns a value and accepts an argument
* `java.util.function.Consumer`: does not return a value but does accept an argument.

.`DemoFunction.java`
[source,java,indent=0]
----
package mcp;

import java.util.function.Function;

public class DemoFunction implements Function<String, String> {

    public String apply(String s) {
        return new StringBuilder(s).reverse().toString();
    }
}
----

Riff supports another functional type called a `Supplier`,
which does not take an argument, but returns a value.

.`DemoSupplier.java`
[source,java]
----
package mcp;

import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.function.Supplier;

public class DemoSupplier implements Supplier<String> {

	private List<String> kingsBook = Arrays.asList(
            "YKCOWREBBAJ",
            "sevot yhtils eht dna,gillirb sawTâ€™",
            "ebaw eht ni elbmig dna eryg diD",
            ",sevogorob eht erew ysmim llA",
            ".ebargtuo shtar emom eht dnA");

	private final Random random = new Random();

	public String get() {
		int r = random.nextInt() * kingsBook.size();
		return kingsBook.get(r);
	}
}
----

Add the Consumer.

.`DemoConsumer.java`
[source,java]
----
package mcp;

import lombok.extern.java.Log;

import java.util.function.Consumer;

@Log
public class DemoConsumer implements Consumer<String> {

    public void accept(String s) {
        log.info(s);
    }
}
----

=== Executing the function

We will need to create and deploy our function as containers.
We can create our own `Dockerfile`, service description (`.yaml`) configuration,
and container images manually. Conveniently, Riff 0.0.3 will do all this for us!

.Create the `Supplier`
[source,script]
----
riff create --name demofn --input reverse-in\
    --protocol pipes --artifact target/demofn-0.0.1.jar\
    --handler mcp.DemoFunction
----

This command creates a function. You specify the input and output topics, a fully
qualified classname and method, and the artifact (.jar) that contains the class.
Your topics are logical names for pipes that conduct requests and replies between
functions.

The following command will locate your `riff-http-gateway`'s IP and port,
then create an HTTP request that will be sent to the `reverse-in` topic.
We tell Riff to wait for a response payload from the input topic with
the `--reply` parameter.

.`riff-publish.sh`
[source,script]
----
riff publish --input reverse-in --data OIRAM --reply
----

Ultimately, the `Riff publish` comand issues an HTTP request to a REST API.
You can do the same thing with any standard HTTP client such as `curl`.

.`riff-curl.sh`
[source,script]
----
curl -H Content-Type: text/plain http://192.168.99.100:30101/messages/demoinput -d OIRAM
----